/**
 * 	(c) Mikdore <admin (at) mikadore.eu> 2021
 * 	This file is licensed under the Boost Software License 1.0:
 *  
 * 
 *  Boost Software License - Version 1.0 - August 17th, 2003
 * 
 *	Permission is hereby granted, free of charge, to any person or organization
 *  obtaining a copy of the software and accompanying documentation covered by
 *	this license (the "Software") to use, reproduce, display, distribute,
 *	execute, and transmit the Software, and to prepare derivative works of the
 *	Software, and to permit third-parties to whom the Software is furnished to
 *	do so, all subject to the following:
 *
 *	The copyright notices in the Software and this entire statement, including
 *	the above license grant, this restriction and the following disclaimer,
 *	must be included in all copies of the Software, in whole or in part, and
 *	all derivative works of the Software, unless such copies or derivative
 *	works are solely in the form of machine-executable object code generated by
 *	a source language processor.
 *
 *	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *	FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 *	SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 *	FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 *	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *	DEALINGS IN THE SOFTWARE.
 */
#pragma once
#include <string>
#include <vector>
#include <algorithm>
#include <array>
#include <cstdint>
#include <type_traits>
#include <stdexcept>
#include <optional>
#include <concepts>

namespace bases
{
	/**
	 *  Pre-requisite asserrs
	 */ 
	constexpr char ascii[] = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
	static_assert(std::all_of(std::begin(ascii), std::end(ascii) - 1, [i = 32] (auto c) mutable {
		return c == i++;
	}), "Characters are not ascii compatible.");

	enum class base
	{
		BASE16,
		BASE32,
		BASE64
	};
	
	enum class error
	{
		NONE = 0,
		UNKNOWN,
		BAD_LENGTH,
		BAD_PAD,
		BAD_CHARACTER
	};

	struct decode_error
	{
		constexpr decode_error() = default;
		constexpr decode_error(error, std::size_t, char);

		constexpr error 		type() 		const noexcept;
		constexpr std::size_t 	location() 	const noexcept;
		constexpr char 			character()	const noexcept;

		private:
			error 		err_type	= error::NONE;
			std::size_t pos 		= 0;
			char 		ch			= 0;
	};

	

	template<typename ValueType, std::default_initializable ErrorType = error>
	struct error_opt : public std::optional<ValueType>
	{

		error_opt(ValueType type);
		error_opt(ErrorType err);

		constexpr bool 				error() 		const noexcept;
		constexpr const ErrorType& 	get_error() 	const noexcept;

		private:
			ErrorType 	error_value;
			bool 		error_present = false;
	};
	
	struct options
	{ };

	struct BASEDecodeTable
	{
		private:
			std::array<std::uint8_t, 256> table;
		public:

		template<std::size_t N>
		constexpr BASEDecodeTable(const char (&alphabet)[N]);

		constexpr inline std::uint8_t operator[](char) const noexcept;
	};
	//Globals
	//B64
	constexpr static char BASE64Alphabet[] 	= "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	constexpr static char BASE64URLSafe[] 	= "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	constexpr static auto BASE64Pad			= '=';

	const static BASEDecodeTable BASE64DecodeTable{ BASE64Alphabet };

	/**
	 *  Type helpers
	 */

	template<typename T>
	concept CharLike = std::is_integral_v<std::remove_reference_t<std::remove_cv_t<T>>> && sizeof(T) == 1;

	template<typename Container, typename OutType>
	concept ContainerOut = requires(Container c)
	{
		Container();
		c.reserve(std::size_t{});
		c.push_back(OutType{});
	};


	template<typename C>
	concept StringLike = ContainerOut<C, char>;

	template<typename C>
	concept ByteContainerOut = ContainerOut<C, std::uint8_t>;


	template<typename T>
	concept ByteContainerIn = requires(const T& t)
	{
		t.data();
		std::is_pointer_v<decltype(t.data())>;
		t.size();
	} && CharLike<decltype(*std::declval<T>().data())>;

	template<typename T, ContainerOut<T> C>
	constexpr bool converter_noexcept = 	noexcept(std::declval<C>().push_back(T{}))
										&& 	noexcept(std::declval<C>().reserve(std::size_t{}))
										&& 	noexcept(T{});


	/**
	 * 	Converter templates
	 */ 

	template<base Base>
	struct converter	
	{
		static_assert(Base != Base, "Invalid Base");
	};

	template<>
	struct converter<base::BASE16>
	{
		converter() = delete;

		template<StringLike string_type = std::string>
		constexpr static error_opt<string_type> 					encode(const std::uint8_t*, std::size_t)
																			noexcept(converter_noexcept<char, string_type>);

		template<ByteContainerOut container_type = std::vector<std::uint8_t>>
		constexpr static error_opt<container_type, decode_error> 	decode(const char*, std::size_t)
																			noexcept(converter_noexcept<std::uint8_t, container_type>);
	};

	template<>
	struct converter<base::BASE32>
	{
		converter() = delete;

		template<StringLike string_type = std::string>
		constexpr static error_opt<string_type> 					encode(const std::uint8_t*, std::size_t)
																			noexcept(converter_noexcept<char, string_type>);


		template<ByteContainerOut container_type = std::vector<std::uint8_t>>
		constexpr static error_opt<container_type, decode_error> 	decode(const char*, std::size_t)
																			noexcept(converter_noexcept<std::uint8_t, container_type>);

	};

	template<>
	struct converter<base::BASE64>
	{
		converter() = delete;

		template<StringLike string_type = std::string>
		constexpr static error_opt<string_type> 					encode(const std::uint8_t*, std::size_t) 
																			noexcept(converter_noexcept<char, string_type>);

		template<ByteContainerOut container_type = std::vector<std::uint8_t>>
		constexpr static error_opt<container_type, decode_error> 	decode(const char*, std::size_t)
																			noexcept(converter_noexcept<std::uint8_t, container_type>);
	
	};


	//Raw string literals are not supported by choice

	template<StringLike string_type = std::string, ByteContainerIn container_type>
	error_opt<string_type> b64encode(const container_type& c)
	{
		return converter<base::BASE64>::encode<string_type>((std::uint8_t*)c.data(), c.size());
	}

	template<ByteContainerOut container_type = std::vector<std::uint8_t>>
	error_opt<container_type, decode_error> b64decode(std::string_view sv)
	{
		return converter<base::BASE64>::decode(sv.data(), sv.size());
	}

} // namespace bases

// IMPLEMENTATION

namespace bases
{
	template<typename ValueType, std::default_initializable ErrorType>
	error_opt<ValueType, ErrorType>::error_opt(ValueType val)
	: std::optional<ValueType>(std::move(val)), error_value{}, error_present(false)
	{}

	template<typename ValueType, std::default_initializable ErrorType>
	error_opt<ValueType, ErrorType>::error_opt(ErrorType er)
	: std::optional<ValueType>(std::nullopt), error_value(std::move(er)), error_present(true)
	{}

	template<typename T, std::default_initializable ErrorType>
	constexpr bool error_opt<T, ErrorType>::error() const noexcept 
	{ return error_present; }
	
	template<typename ValueType, std::default_initializable ErrorType>
	constexpr const ErrorType& error_opt<ValueType, ErrorType>::get_error() const noexcept
	{ return error_value; }

	constexpr decode_error::decode_error(error type, std::size_t pos, char c)
	:  err_type(type), pos(pos), ch(c)
	{}

	constexpr error			decode_error::type() 		const noexcept
	{ return err_type; }

	constexpr char 			decode_error::character() 	const noexcept
	{ return ch; }

	constexpr std::size_t 	decode_error::location() 	const noexcept 
	{ return pos; }

	//helper type not intended to be used by users

	template<std::size_t N>
	constexpr BASEDecodeTable::BASEDecodeTable(const char (&alphabet)[N])
	{
		static_assert(N <= 96 && N > 0, "The alphabet must contain only unique, printable ASCII symbols");
		
		std::fill(std::begin(table), std::end(table), 0xFF);
		table['='] = 0x40; //special - so we can check for it's presence
		for(auto i = 0u; auto c : alphabet)
		{
			table[c] = i;
			i++;
		}
	}
 
	constexpr inline std::uint8_t BASEDecodeTable::operator[](char c) const noexcept
	{ return table[c]; }


	template<StringLike string_type>
	constexpr inline error BASE64FinalChunk(string_type& out, std::size_t size, std::size_t i, const std::uint8_t* data)
								noexcept(converter_noexcept<char, string_type>)
	{
		switch(size)
		{
			case 1: {
				out.push_back( BASE64Alphabet[ 	data[i] 				>> 2 ]);
				out.push_back( BASE64Alphabet[ (data[i] & 0b00000011) 	<< 4 ]);
				out.push_back( BASE64Pad );
				out.push_back( BASE64Pad );
				return error::NONE;	
			}

			case 2: {
				out.push_back( BASE64Alphabet[ 						data[i] 	>> 2									]);
				out.push_back( BASE64Alphabet[ ((	0b11110000 & 	data[i+1]) 	>> 4) | ((0b00000011 & data[i  ]) << 4) ]);
				out.push_back( BASE64Alphabet[ ((	0b00001111 &	data[i+1]) 	<< 2)									]);
				out.push_back( BASE64Pad );
				return error::NONE;
			}
			
			case 0: return error::NONE;

			default: return error::UNKNOWN;
		}
	}

	template<StringLike string_type>
	constexpr error_opt<string_type> converter<base::BASE64>::encode(const std::uint8_t* data, std::size_t size)
																noexcept(converter_noexcept<char, string_type>)
	{
		string_type out{};

		out.reserve( ((4 * size / 3) + 3) & ~3 ); //output length including padding

		if(size < 3)
		{
			if(auto err = BASE64FinalChunk(out, size, 0, data); err == error::NONE)
			{
				return error_opt{out};
			} else return error_opt<string_type>{err};
		}

		auto i = 0ul;

		for(; (size - i) >= 3; i += 3)
		{

			out.push_back( BASE64Alphabet[						data[i	] 	>> 2									]);							
			out.push_back( BASE64Alphabet[ ((	0b11110000 & 	data[i+1]) 	>> 4) | ((0b00000011 & data[i  ]) << 4) ]);
			out.push_back( BASE64Alphabet[ ((	0b00001111 & 	data[i+1]) 	<< 2) | ((0b11000000 & data[i+2]) >> 6) ]);
			out.push_back( BASE64Alphabet[ 		0b00111111 & 	data[i+2]											]);

		}

		if(auto err = BASE64FinalChunk(out, size - i, i, data); err == error::NONE)
		{
			return error_opt{out};
		} else return error_opt<string_type>{err};
	}

	template<ByteContainerOut container_type>
	constexpr error_opt<container_type, decode_error> converter<base::BASE64>::decode(const char* data, std::size_t size)
																				noexcept(converter_noexcept<std::uint8_t, container_type>)
	{
		container_type out{};
		
		if(size % 4 != 0)
		{
			return error_opt<container_type, decode_error>{decode_error(error::BAD_LENGTH, 0, 0)};
		}

		out.reserve((size/4)*3);
		
		auto i = 0ul;

		for(; (size - i) >= 4; i += 4)
		{
			auto a = BASE64DecodeTable[data[i	 ]];
			auto b = BASE64DecodeTable[data[i + 1]];
			auto c = BASE64DecodeTable[data[i + 2]];

			auto d = BASE64DecodeTable[data[i + 3]];

			if((a | b | c | d) & 0x80) //highest bit == bad character
			{
				auto index = 0ul;
				char c = 0;

				if		(a & 0x80)
					index = i, c = data[i];
				else if	(b & 0x80)
					index = i + 1, c = data[i + 1]; 
				else if	(c & 0x80)
					index = i + 2, c = data[i + 2];
				else if	(d & 0x80)
					index = i + 3, c=  data[i + 3];

				return error_opt<container_type, decode_error>{decode_error(error::BAD_CHARACTER, index, c)};
			}
			if((a | b | c | d) & 0x40) //pad character == last block
			{
				if((a | b) & 0x40)
				{
					return error_opt<container_type, decode_error>{decode_error(error::BAD_PAD, i, data[i])};
				};
				if((c & 0x40) && !(d & 0x40))
				{
					return error_opt<container_type, decode_error>{decode_error(error::BAD_PAD, i + 3, data[i + 3])};
				}

				if(c & 0x40)
				{
					out.push_back((a << 2) | (b >> 4));  
					return out;
				} else 
				{
					out.push_back((a 		<< 2) 	| (b >> 4));
					out.push_back((0xf & b) << 4	| (c >> 2));
					return out;
				}
			}

			out.push_back((a << 2) | (b >> 4));
			out.push_back((b << 4) | (c >> 2));
			out.push_back((c << 6) | d);

		}

		return out;

	}
/*

	template<StringLike string_type>
	string_type converter<base::BASE32>::encode(const std::uint8_t*, std::size_t)
	{
	}
	template<StringLike string_type>
	string_type converter<base::BASE16>::encode(const std::uint8_t*, std::size_t)
	{
	}
*/

} // namespace bases